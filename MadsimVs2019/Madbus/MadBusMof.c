//
// .c - Code generated by wmimofck tool
//
// Finish code by doing all TODO: sections
//

#include <wdm.h>
#include <wmistr.h>
#include <wmiguid.h>
#include <wmilib.h>

//
// Include data header for classes
#include ".h"


//
// TODO: Place the contents in this device extension into the driver's
//       actual device extension. It is only defined here to supply
//       a device extension so that this file can be compiled on its own
//
#ifdef MAKE_THIS_COMPILE
typedef struct DEVICE_EXTENSION
{
    WMILIB_CONTEXT WmiLib;
    PDEVICE_OBJECT physicalDevObj;
} DEVICE_EXTENSION, *PDEVICE_EXTENSION;
#endif

NTSTATUS
InitializeWmilibContext(
    IN PWMILIB_CONTEXT WmilibContext
    );

NTSTATUS
FunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    );

NTSTATUS
ExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG InstanceIndex,
    IN ULONG GuidIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    );

NTSTATUS
QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    );

NTSTATUS
QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,QueryWmiRegInfo)
#pragma alloc_text(PAGE,QueryWmiDataBlock)
#pragma alloc_text(PAGE,SetWmiDataBlock)
#pragma alloc_text(PAGE,SetWmiDataItem)
#pragma alloc_text(PAGE,ExecuteWmiMethod)
#pragma alloc_text(PAGE,FunctionControl)
#pragma alloc_text(PAGE,InitializeWmilibContext)
#endif

//
// TODO: Decide if your MOF is going to be part of your driver as a resource
//       attached to it. If this is done then all MOF in the resource will be
//       added to the schema. If this is the case be sure that 
//       USE_BINARY_MOF_RESOURCE is defined. MOF can also be reported at 
//       runtime via a query to the driver. This can be useful if you want
//       the MOF reported to the schema to be dynamic. If MOF is reported via
//       a query then USE_BINARY_MOF_QUERY should be defined.

#define USE_BINARY_MOF_QUERY
#define USE_BINARY_MOF_RESOURCE

#ifdef USE_BINARY_MOF_QUERY
//
// MOF data can be reported by a device driver via a resource attached to
// the device drivers image file or in response to a query on the binary
// mof data guid. Here we define global variables containing the binary mof
// data to return in response to a binary mof guid query. Note that this
// data is defined to be in a PAGED data segment since it does not need to
// be in nonpaged memory. Note that instead of a single large mof file
// we could have broken it into multiple individual files. Each file would
// have its own binary mof data buffer and get reported via a different
// instance of the binary mof guid. By mixing and matching the different
// sets of binary mof data buffers a "dynamic" composite mof would be created.

#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg("PAGED")
#endif

UCHAR BinaryMofData[] =
{
    #include ".x"
};
#ifdef ALLOC_DATA_PRAGMA
   #pragma data_seg()
#endif
#endif

//
// Define symbolic names for the guid indexes
#define MadBusWmiInfoGuidIndex    0
#define MadBusWmiControlGuidIndex    1
#ifdef USE_BINARY_MOF_QUERY
#define BinaryMofGuidIndex   2
#endif
//
// List of guids supported

GUID MadBusWmiInfoGUID = MadBusWmiInfoGuid;
GUID MadBusWmiControlGUID = MadBusWmiControlGuid;
#ifdef USE_BINARY_MOF_QUERY
GUID BinaryMofGUID =         BINARY_MOF_GUID;
#endif

//
// TODO: Make sure the instance count and flags are set properly for each
//       guid
WMIGUIDREGINFO GuidList[] =
{
    {
        &MadBusWmiInfoGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
    {
        &MadBusWmiControlGUID,                        // Guid
        1,                               // # of instances in each device
        0                                // Flags
    },
#ifdef USE_BINARY_MOF_QUERY
    {
        &BinaryMofGUID,
        1,
        0
    }
#endif
};

#define GuidCount (sizeof(GuidList) / sizeof(WMIGUIDREGINFO))

//
// We need to hang onto the registry path passed to our driver entry so that
// we can return it in the QueryWmiRegInfo callback. Be sure to store a copy
// of it into RegistryPath in the DriverEntry routine
//
extern UNICODE_STRING RegistryPath;

NTSTATUS SystemControl(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for System Control IRPs (MajorFunction == IRP_MJ_SYSTEM_CONTROL)

Arguments:

    DeviceObject 
    Irp

Return Value:

    NT status code

--*/
{
    PWMILIB_CONTEXT wmilibContext;
    NTSTATUS status;
    SYSCTL_IRP_DISPOSITION disposition;
    PDEVICE_EXTENSION devExt = DeviceObject->DeviceExtension;

    //
    // TODO: Point at the WMILIB context within the device extension
    wmilibContext = &devExt->WmiLib;

    //
    // Call Wmilib helper function to crack the irp. If this is a wmi irp
    // that is targetted for this device then WmiSystemControl will callback
    // at the appropriate callback routine.
    //
    status = WmiSystemControl(wmilibContext,
                              DeviceObject,
                              Irp,
                              &disposition);

    switch(disposition)
    {
        case IrpProcessed:
        {
            //
            // This irp has been processed and may be completed or pending.
            break;
        }

        case IrpNotCompleted:
        {
            //
            // This irp has not been completed, but has been fully processed.
            // we will complete it now.
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            break;
        }

        case IrpForward:
        case IrpNotWmi:
        default:
        {
            //
            // This irp is either not a WMI irp or is a WMI irp targetted
            // at a device lower in the stack.

            // TODO: Forward IRP down the device stack to the next device
            //       Or if this is a PDO then just complete the irp without
            //       touching it.
            break;
        }

    }

    return(status);
}
NTSTATUS
QueryWmiRegInfo(
    IN PDEVICE_OBJECT DeviceObject,
    OUT ULONG *RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    WmiCompleteRequest.

Arguments:

    DeviceObject is the device whose registration info is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver. The caller
         does NOT free this buffer.

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL. The caller does NOT free this
        buffer.

    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in
        *RegFlags.

Return Value:

    status

--*/
{
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;

    //
    // Return the registry path for this driver. This is required so WMI
    // can find your driver image and can attribute any eventlog messages to
    // your driver.
    *RegistryPath = &RegistryPath;
        
#ifndef USE_BINARY_MOF_RESOURCE
    //
    // Return the name specified in the .rc file of the resource which
    // contains the bianry mof data. By default WMI will look for this
    // resource in the driver image (.sys) file, however if the value
    // MofImagePath is specified in the driver's registry key
    // then WMI will look for the resource in the file specified there.
    RtlInitUnicodeString(MofResourceName, L"MofResourceName");
#endif

    //
    // Specify that the driver wants WMI to automatically generate instance
    // names for all of the data blocks based upon the device stack's
    // device instance id. Doing this is STRONGLY recommended since additional
    // information about the device would then be available to callers.
    *RegFlags = WMIREG_FLAG_INSTANCE_PDO;

    //
    // TODO: Assign the physical device object for the device stack to *Pdo
    *Pdo = devExt->physicalDevObj;

    return(STATUS_SUCCESS);
}

NTSTATUS
QueryWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG InstanceCount,
    IN OUT PULONG InstanceLengthArray,
    IN ULONG BufferAvail,
    OUT PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    all instances of a data block. If the driver can satisfy the query within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the query is satisfied.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceCount is the number of instnaces expected to be returned for
        the data block.

    InstanceLengthArray is a pointer to an array of ULONG that returns the
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.

    BufferAvail on entry has the maximum size available to write the data
        blocks.

    Buffer on return is filled with the returned data blocks. Note that each
        instance of the data block must be aligned on a 8 byte boundry.


Return Value:

    status

--*/
{
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;
    ULONG sizeNeeded;

    switch(GuidIndex)
    {
        case MadBusWmiInfoGuidIndex:
        {
            //
            // TODO: Check that the size of the buffer passed is large enough
            //       for all of the instances requested and if so fill Buffer
            //       with the data. Make sure that each instance begins on an
            //       8 byte boundry.
            //
            break;
        }

        case MadBusWmiControlGuidIndex:
        {
            //
            // TODO: Check that the size of the buffer passed is large enough
            //       for all of the instances requested and if so fill Buffer
            //       with the data. Make sure that each instance begins on an
            //       8 byte boundry.
            //
            break;
        }

#ifdef USE_BINARY_MOF_QUERY
        case BinaryMofGuidIndex:
        {
            //
            // TODO: If the driver supports reporting MOF dynamically, 
            //       change this code to handle multiple instances of the
            //       binary mof guid and return only those instances that
            //       should be reported to the schema
            //
            sizeNeeded = sizeof(BinaryMofData);

            if (BufferAvail < sizeNeeded)
            {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                RtlCopyMemory(Buffer, BinaryMofData, sizeNeeded);
                *InstanceLengthArray = sizeNeeded;
                status = STATUS_SUCCESS;
            }
            break;
        }
#endif

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    //
    // Complete the irp. If there was not enough room in the output buffer
    // then status is STATUS_BUFFER_TOO_SMALL and sizeNeeded has the size
    // needed to return all of the data. If there was enough room then
    // status is STATUS_SUCCESS and sizeNeeded is the actual number of bytes
    // being returned.
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}

NTSTATUS
SetWmiDataBlock(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to change the contents of
    a data block. If the driver can change the data block within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the data is changed.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    NTSTATUS status;
    struct DEVICE_EXTENSION * devExt = DeviceObject->DeviceExtension;


    switch(GuidIndex)
    {

        case MadBusWmiInfoGuidIndex:
        {            
            //
            // TODO: Validate InstanceIndex, BufferSize and Buffer contents
            //       and if valid then set the underlying data block, write
            //       to the hardware, etc.
            break;
        }


        case MadBusWmiControlGuidIndex:
        {            
            //
            // TODO: Validate InstanceIndex, BufferSize and Buffer contents
            //       and if valid then set the underlying data block, write
            //       to the hardware, etc.
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);


}
       
NTSTATUS
SetWmiDataItem(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG DataItemId,
    IN ULONG BufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to change the contents of
    a data block. If the driver can change the data block within
    the callback it should call WmiCompleteRequest to complete the irp before
    returning to the caller. Or the driver can return STATUS_PENDING if the
    irp cannot be completed immediately and must then call WmiCompleteRequest
    once the data is changed.

Arguments:

    DeviceObject is the device whose data block is being changed

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    NTSTATUS status;

    switch(GuidIndex)
    {
        case MadBusWmiInfoGuidIndex:
        {            
            //
            // TODO: Validate InstanceIndex, DataItemId, BufferSize 
            //       and Buffer contents
            //       and if valid then set the underlying data item, write
            //       to the hardware, etc.
            break;
        }
        case MadBusWmiControlGuidIndex:
        {            
            //
            // TODO: Validate InstanceIndex, DataItemId, BufferSize 
            //       and Buffer contents
            //       and if valid then set the underlying data item, write
            //       to the hardware, etc.
            break;
        }
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     0,
                                     IO_NO_INCREMENT);

    return(status);
}
NTSTATUS
ExecuteWmiMethod(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN ULONG InstanceIndex,
    IN ULONG MethodId,
    IN ULONG InBufferSize,
    IN ULONG OutBufferSize,
    IN PUCHAR Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to execute a method. If
    the driver can complete the method within the callback it should
    call WmiCompleteRequest to complete the irp before returning to the
    caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device whose method is being executed

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    MethodId has the id of the method being called

    InBufferSize has the size of the data block passed in as the input to
        the method.

    OutBufferSize on entry has the maximum size available to write the
        returned data block.

    Buffer is filled with the input buffer on entry and returns with
         the output data block

Return Value:

    status

--*/
{
    ULONG sizeNeeded = 0;
    NTSTATUS status;

    switch(GuidIndex)
    {
            
        case MadBusWmiControlGuidIndex:
        {
            switch(MethodId)
            {
                case MadBusWmiControl1:
                {            
                    //
                    // TODO: Validate InstanceIndex, InBufferSize 
                    //       and Buffer contents to ensure that the 
                    //       input buffer is valid and OutBufferSize is
                    //       large enough to return the output data.
                    //
                    break;
                }

                case MadBusWmiControl2:
                {            
                    //
                    // TODO: Validate InstanceIndex, InBufferSize 
                    //       and Buffer contents to ensure that the 
                    //       input buffer is valid and OutBufferSize is
                    //       large enough to return the output data.
                    //
                    break;
                }

                case MadBusWmiControl3:
                {            
                    //
                    // TODO: Validate InstanceIndex, InBufferSize 
                    //       and Buffer contents to ensure that the 
                    //       input buffer is valid and OutBufferSize is
                    //       large enough to return the output data.
                    //
                    break;
                }

                default:
                {
                    status = STATUS_WMI_ITEMID_NOT_FOUND;
                    break;
                }
            }
            break;
        }

        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    }

    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     status,
                                     sizeNeeded,
                                     IO_NO_INCREMENT);

    return(status);
}
NTSTATUS
FunctionControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN ULONG GuidIndex,
    IN WMIENABLEDISABLECONTROL Function,
    IN BOOLEAN Enable
    )
/*++

Routine Description:

    This routine is a callback into the driver to enabled or disable event
    generation or data block collection. A device should only expect a
    single enable when the first event or data consumer enables events or
    data collection and a single disable when the last event or data
    consumer disables events or data collection. Data blocks will only
    receive collection enable/disable if they were registered as requiring
    it. If the driver can complete enabling/disabling within the callback it
    should call WmiCompleteRequest to complete the irp before returning to
    the caller. Or the driver can return STATUS_PENDING if the irp cannot be
    completed immediately and must then call WmiCompleteRequest once the
    data is changed.

Arguments:

    DeviceObject is the device object

    GuidIndex is the index into the list of guids provided when the
        device registered

    Function specifies which functionality is being enabled or disabled

    Enable is TRUE then the function is being enabled else disabled

Return Value:

    status

--*/
{
    NTSTATUS status;

    switch(GuidIndex)
    {
        case MadBusWmiInfoGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        case MadBusWmiControlGuidIndex:
        {
            //
            // TODO: Delete this entire case if data block does not have the
            //       WMIREG_FLAG_EXPENSIVE flag set
            //
            if (Enable)
            {
                //
                // TODO: Datablock collection is being enabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       first data consumer opens this data block. If
                //       anything needs to be done to allow data to be 
                //       collected for this data block then it should be
                //       done here
                //
            } else {
                //
                // TODO: Datablock collection is being disabled. If this
                //       data block has been marked as expensive in the
                //       guid list then this code will be called when the
                //       last data consumer closes this data block. If
                //       anything needs to be done to cleanup after data has 
                //       been collected for this data block then it should be
                //       done here
                //
            }
            break;
        }

        
        default:
        {
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    }
    
    status = WmiCompleteRequest(
                                     DeviceObject,
                                     Irp,
                                     STATUS_SUCCESS,
                                     0,
                                     IO_NO_INCREMENT);
    return(status);
}
NTSTATUS
InitializeWmilibContext(
    IN PWMILIB_CONTEXT WmilibContext
    )
/*++

Routine Description:

    This routine will initialize the wmilib context structure with the
    guid list and the pointers to the wmilib callback functions. This routine
    should be called before calling IoWmiRegistrationControl to register
    your device object.

Arguments:

    WmilibContext is pointer to the wmilib context.

Return Value:

    status

--*/
{
    RtlZeroMemory(WmilibContext, sizeof(WMILIB_CONTEXT));
    
    WmilibContext->GuidCount = GuidCount;
    WmilibContext->GuidList = GuidList;    
    
    WmilibContext->QueryWmiRegInfo = QueryWmiRegInfo;
    WmilibContext->QueryWmiDataBlock = QueryWmiDataBlock;
    WmilibContext->SetWmiDataBlock = SetWmiDataBlock;
    WmilibContext->SetWmiDataItem = SetWmiDataItem;
    WmilibContext->ExecuteWmiMethod = ExecuteWmiMethod;
    WmilibContext->WmiFunctionControl = FunctionControl;

    return(STATUS_SUCCESS);
}